## All Contents

→ Windows Kernel Tutorial<br>
＿ All About DLL<br>
＿ All About Driver<br>
＿ CE Dematerializer<br>
＿ Broken DEMACIA<br>

## Windows Kernel Tutorial

해킹에 대해서 이야기 할 때 커널에 관한 이야기가 엄청 많이 나옵니다.<br>
흥미 있는 주제들에 대해서만 이야기 해보자면..<br>

- 게임 매크로를 만들려면 SSDT 후킹을 할 줄 알아야 한다.
- 보안 모듈을 우회하기 위해선 커널을 잘 알아야 한다.
- PC방에 소켓 프록시를 숨겨 놓기 위해는 커널을 잘 알아야 한다.

커널이 무엇이고 왜 나쁜 짓을 방어하는 기술들은 커널에 치중되어 있을까요?<br>
또한 앞으로 연재 할 내용을 이해 혹은 학습 하기 위해서 필요한 지식들에 대해서 이야기 해 보도록 하겠습니다.<br>

## DLL
Dynamic Linked Library, 동적으로 연결되는 라이브러리라는 의미입니다.<br>
프로그램이 메모리에 올라오는 시점에 라이브러리의 참조가 이루어 지므로 유지보수를 따로 할 수 있다는 점이 있습니다.<br>
윈도우에서 기본적으로 제공하는 여러 API들 또한 DLL로 이루어진 경우가 많으며 DLL의 EAT를 참조하여, 
PE 로더가 IAT를 채워주는 방식으로 구성되어 있습니다.<br>
<IAT/EAT 이미지><br>
프로그래머는 DLL에 정의된 함수를 사용 할 때 문서를 참조하여 인자만 채워주면 그 함수를 사용 할 수 있게 됩니다.<br> 

## API
Application Programming Interface 줄여서 API라고 불리웁니다.<br>
프로그래머가 자주 하는 작업 혹은 어려운 작업들을 단순히 인자 몇 개와 플래그 셋팅으로 결과를 얻어 올 수 있는 효율적인 수단인 것이죠.<br>
즉, API들은 문서화가 되어 있습니다. Windows API들이라면 MSDN에 NaverAPI라면 네이버 개발자 센터에 문서화가 되어 있는 것처럼요.<br>

<MSDN에 정의되어 있는 스펙 이미지><br>
<네이버에 정의되어 있는 스펙 이미지><br>

그렇다면 API와 함수의 다른점에 대해서 다시 한 번 이야기 해 보도록 하겠습니다.<br>
단순한 말 장난이라고 생각 하는데 함수는 좀 더 넓은 개념이고 API는 좁은 개념이라고 할 수 있습니다.<br>
함수의 개념은 수학에서도 사용 될 수 있지만 API는 프로그램을 만들기 위한 프로그래밍적 제공자라고 바꿔 말할 수 있습니다.<br>
최종적으로 제공되는 라이브러리에서 문서화되지 않은 혹은 알려지지 않은 함수들은 API라는 개념에 포함 될 수 없다는 것입니다.<br>

## SYS
.sys 확장자를 가지고 있는 윈도우 드라이버에 대해 이야기 해 보도록 하겠습니다.<br>
드라이버들은 실제 현실 세계에 존재하는 장치들(마우스, 하드웨어, 그래픽 등)의 처리를 위해 프로그래밍 되는 인터페이스입니다.<br>
이러한 장치를 다루기 위해는 필연적으로 커널에 접근을 하게 됩니다.<br>
즉, 윈도우 유저모드에서 커널에 접근하기 위해서는 드라이버라는 매개체를 통해야 되는 것이죠.<br>
유저모드 프로그램에서는 이미 로드되어있는 드라이버나 로드 할 수 있는 드라이버와 DeviceIoControl 함수로 코드를 주고받아 실 행동은 드라이버가 취하는 방식으로 동작 하는 것 입니다.<br>

## Map of User and Kernel
<OS Internal Kernel Map Image><br>
\- 익스큐티브<br>
ExXXXX 함수<br>
메모리 관리, 프로세스 및 스레드 관리, I/O, IPC<br>
프로세스, 디렉토리, 드라이버와 같은 타입들이 실제로 메모리상에 올라온, 인스턴스화 된 상태를 익스큐티브 오브젝트라 함.

\- 커널<br>
KeXXXX 함수<br>
스레드 스케줄링, 인터럽트 및 예외 디스패칭, 멀티 프로세스 동기화 같은 저수준 코드로 이루어져 있음<br>

## What's mean Native?

<NTDLL.dll Import table 이미지>
<SMSS.exe 프로세스의 라이브러리 미참조 이미지>
Native Library는 다른 라이브러리들과 연관성이 없음.

## API부터 실제 소스코드까지

kernel32.dll -> kernelbase.dll -> ntdll.dll ->  | system call -> ssdt -> ntoskrnl.exe -> ntcreateprocess<br>
CreateProcessA/W -> CreateProcessInternal ->    | NtCreateProcess(0x??) -> NtCreateProcess<br>

이 쯤되면 결론이 나옵니다.<br>
왜 보안 모듈들이나 나쁜 짓들을 막는 방법들은 커널에 집중되어 있는지를<br>
왜냐하면 유저모드에서 사용되는 API들은 그 기술을 구현하기 위한 실제 소스코드가 없고 단순히 전달만 해주는 형식입니다.<br>
바꾸어 말하자면 유저모드 API들을 지지고 볶아도 최종적인 커널모드 영역의 API를 건드린다면 게임오버이기 때문에 그렇습니다.<br>


## 결론
여기까지 하이레벨에서 로우레벨 까지의 과정을 간략하게나마 살펴 보았습니다.<br>
